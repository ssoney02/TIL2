# 3. CPU

## 레지스터

: CPU 안에 있는 임시 저장장치

→ 프로그램을 이루는 데이터, 명렁어가 프로그램의 실행 전후로 레지스터에 저장됨

### 레지스터 종류

- 프로그램 카운터
    
    (= 명령어 포인터)
    
    : 메모리에서 다음으로 읽어 들일 명령어의 주소
    
    → 일반적으로 1씩 증가함 = 다음으로 읽어 들일 메모리 주소가 1씩 증가함
    
    ⇒ 메모리에 저장된 프로그램이 순차적으로 실행되는 이유
    
    (근본적으로 프로그램 카운터 값이 1씩 증가하며 실행되기 떄문!)
    
    - 프로그램 실행 흐름이 순차적이지 않은 경우
        
        프로그램 카운터 값이 임의의 위치로 변경됨
        
- 명령어 레지스터
    
    해석할 명령어(방금 읽어들인 명령어)를 저장하는 레지스터
    
    → 다른 cpu 내의 제어장치가 명렁어 레지스터 내의 명렁어를 해석한 뒤 ALU(산술논리연산자)가 연산하도록 시키거나 다른 부품으로 제어 신호 보냄
    
- 범용 레지스터
    
    데이터, 명령어, 주소 모두 저장 가능
    
    - 보통 CPU안에 범용 레지스터가 여러 개 들어있음
- 플래그 레지스터
    
    : 플래그 값(연산 결과 혹은 CPU 상태에 대한 부가 정보)을 저장하는 레지스터
    
    - 플래그: cpu가 명령어를 처리하는 과정에서 반드시 참조해야 할 상태 정보
    
    ![image.png](attachment:6563615f-98bd-41e1-b300-8911b023fa6f:image.png)
    
- 스택 포인터
    
    메모리 → 실행 중인 프로그램들 적재됨
    
    - 실행 중인 각 프로그램 → 스택과 같은 형태로 사용가능한 주소 공간을 하나 이상 가짐
    - 스택 영역: 스택처럼 사용하자고 약속된 메모리 영역
    - 스택 포인터: 메모리 내 스택 영역의 최상단 스택 데이터 위치를 가리키는 특별한 레지스터를 말함
    
    ⇒ 마지막으로 스택에 저장된 데이터의 위치를 가리키는 레지스터
    
    ⇒ 스택이 채워진 정도를 나타내는 레지스터
    

## 인터럽트

: CPU의 작업을 방해하는 신호

### 인터럽트 구분

### 1. 동기 인터럽트

: CPU에 의해 발생하는 인터럽트

ex. 프로그래밍 오류와 같은 예외적인 상황을 마주쳤을 때 발생하는 인터럽트

⇒ ‘ 예외’라고도 부름

### 2. 비동기 인터럽트

: 주로 입출력장치에 의해  발생하는 인터럽트

- 알림의 역할을 함
    - ~~입출력 장치 → cpu???~~
    - cpu → 입출력 장치에 입출력 작업 요청. 작업을 끝낸 입출력장치가 cpu에 완료 알림(인터럽트)를 보냄
    - 입출력 장치가 입력을 받았을 때 이를 처리 하기 위해 cpu에 입력 알림(인터럽트) 보냄

### 하드웨어 인터럽트???

→ 대부분의 하드웨어 인터럽트는 비동기 인터럽트(외부에 의해 발생하는 인터럽트)에 포함됨

그렇다고 완전 동일한 것은 아님..

- 알림과 같은 인터럽트..
- CPU가 효율적으로 명령어를 처리하기 위해 하드웨어 인터럽트를 사용함
    - **“폴링”**: 작업 완료 여부를 주기적으로 확인하는 것(입춝력 장치의 상태, 처리할 데이터 유무)
    - 입출력장치와 CPU의 작업처리 속도가 다름 → 알림을 보내주지 않으면 CPU에서 작업이 끝났는지 계속 확인해야됨(비효율적..)

- CPU가 하드웨어 인터럽트를 처리하는 순서
    1. 입출력 장치→ CPU에 인터럽트 요청 신호 보냄
    2. CPU: 실행 사이클 끝나고 명령어 인출 전에 인터럽트 여부 확인
    3. CPU: 인터럽트 요청 확인, 인터럽트 플래그로 현재 인터럽트를 받아들일 수 있는지 여부 확인
    4. 인터럽트 받아들일 수 있으면 CPU가 지금까지의 작업을 백업
    5. CPU: 인터럽트 벡터를 참조하여 인터럽트 서비스 루틴 실행
    6. 인터럽트 서비스 루틴 실행이 끝나면 4번에서 백업해둔 작업을 복구하여 실행 재개
- 인터럽트 관련 용어
    - **인터럽트 요청 신호**: 인터럽트가 CPU의 정상적인 진행 흐름을 방해하기 때문에 인터럽트 전에 CPU에게 인터럽트 가능 여부를 확인해야됨. 이를 위한 신호
    - **인터럽트 플래그**: 하드웨어 인터럽트를 받아들일지, 무시할지를 결정하는 플래그
        - but, 인터럽트 플래그가 불가능으로 설정되어있어도 무시할 수 없는 인터럽트 요청도 o
            - 막을 수 있는 인터럽트
            - 막을 수 없는 인터럽트(NMI) → 정전, 하드웨어 고장으로 인한 인터럽트 (가장 우선순위가 높은 인터럽트)
    - **인터럽트 서비스 루틴(= 인터럽트 핸들러)**: 인터럽트를 처리하기 위한 프로그램
        
        → 인터럽트가 발생했을 때, 해당 인터럽트를 어떻게 처리하고 작동해야 할 지에 대한 정보
        
        “cpu가 인터럽트를 처리한다” = “인터럽트 서비스 루틴을 실행하고, 본래 수행하던 작업으로 다시 되돌아온다”
        
    - **인터럽트 벡터:** 인터럽트 서비스 루틴을 식별하기 위한 정보
        - 인터럽트 서비스 루틴의 시작주소를 포함함 → 인터럽트 벡터를 통해 처음부터 특정 인터럽트 서비스 루틴 실행 가능
        
        → 인터럽트 서비스 루틴도 데이터와 명령어로 이루어짐 → 레지스터들을 사용해야됨. → 지금까지의 작업들을 따로 백업해둬야됨(cpu: 인터럽트 서비스 루틴 실행 전에 프로그램 카운터 값 등 현재 프로그램을 재개하기 위해 모든 내용을 메모리 내 스택에 백업함)
        

![인터럽트 사이클](attachment:ad6759e3-0ce2-4677-bf28-b0a6e3c8b25e:image.png)

인터럽트 사이클

### 예외(= 동기 인터럽트)

- 종류
    
    폴트, 트램, 중단, 소프트웨어 인터럽트 등
    
    - 폴트
        
        예외 처리 직후, 예외가 발생한 명령어부터 실행 재개하는 예외
        
        (ex. 명령어를 실행해야되는데 메모리가 아닌 보조장치에 저장되어 있는 경우..)
        
    - 트랩
        
        예외처리 직후, 예외가 발생한 명령어의 다음 명령어부터 실행을 재개하는 예외
        
        ex. 디버깅 - 브레이크 포인트 
        
    - 중단
        
        : cpu가 실행 중인 프로그램을 강제로 중단시킬 수 밖에 없는 심각한 오류를 발견했을 때 발생하는 예외
        
    - 소프트웨어 인터럽트: 시스템 콜이 발생했을 때 발생하는 예외
    

## CPU 성능 향상을 위한 설계

### CPU 클럭 속도

- 클럭: 컴퓨터의 부품을 일사불란하게 움직일 수 있게 하는 시간 단위
    - 클럭의 주기에 맞춰 한 레지스터에서 다른 레지스터로 데이터가 이동하거나 ALU에서 연산이 수행되고, 메모리에 저장된 명령어를 읽어들이는 것
- 클럭 속도: 헤르츠(Hz) 단위로 측정
    - 클럭이 1초에 몇 번 반복되는지를 나타냄
    - 1초에 100번 반복 → cpu의 클럭속도: 100Hz
    - 클럭 속도가 높아지면 cpu가 명령어 사이클을 더 빠르게 반복 → 대체로 cpu성능도 높아지지만,, 필요 이상으로 높이면 발열 문제로 인해 한계 o

### 멀티코어와 멀티스레드

- 코어: cpu안에 명령어를 읽어들이고, 해석하고 실행하는 부품이 여러 개 존재할 수 있게되어 코어라고 묶어서 부름

![image.png](attachment:f6e851ba-1f66-48b0-8eb6-1a33ad4a262c:image.png)

- 멀티코어 CPU(= 멀티코어 프로세서): 여러 개의 코어를 포함하고 있는 CPU
- 스레드
    1. 하드웨어적인 스레드(=하드웨어 스레드, 논리 프로세서)
        
        : 하나의 코어가 동시에 처리하는 명령어의 단위
        
        - 멀티스레드 프로세서(멀티스레드 CPU): 하나의 코어로 여러 명령어를 동시에 처리하는 CPU
        
        ⇒ 병렬성(작업을 물리적으로 동시에 처리하는 성질)
        
    2. 소프트웨어적인 스레드(= 스레드)
        
        : 하나의 프로그램에서 독립적으로 실행되는 단위
        
        → 메모리에 적재된 해당 프로그램을 구성하는 여러 부분이 동시에 실행될 수 있다…..?
        
        ⇒ 동시성(동시에 작업을 처리하는 것처럼 보이는 성질. 빠르게 작업을 번갈아 가며 처리하는 경우..)
        

## 파이프라이닝을 통한 명령어 병렬 처리

- 명령어 병렬 처리 기법: 여러 명령어를 동시에 처리하여 CPU를 한시도 쉬지 않고 작동시켜 CPU의 성능을 높이는 기법
- 명렁어 파이프라이닝: 명령어들을 명령어 파이프라인에 넣고 동시에 처리하는 기법
    - 하나의 명령어가 처리되는 과정
        1. 명령어 인출
        2. 명령어 해석
        3. 명령어 실행
        4. 결과 저장
    
    ❗같은 단계가 겹치지만 않는다면 CPU가 각각의 단계를 동시에 실행 가능!
    
    → CPU: 하나의 명령어가 인출되는 동안 다른 명령어 실행 가능
    
    ![image.png](attachment:518630c4-34b2-4def-8bb9-5485740a27c4:image.png)
    

- 슈퍼스칼라: CPU 내부에 여러 명령어 파이프라인을 포함하는 구조
    
    → 슈퍼스칼라 프로세서(= 슈퍼스칼라 CPU)
    

명령어 집합

→ 명령어 병렬 처리에 유리한 명령어집합

RISC: 애플 M1

→ 1클럭 내외로 실행되는 명령어 지향

→ 불리한 명령어 집합

CISC: 인텔 x86, x86-64, 

→ 적은 수의 명령어로도 프로그램 실행 가능 but, 하나의 명령어 실행에 여러 클럭 주기 필요, 명령어의 크기 및 실행되기까지의 시간이 일정하지x

- 파이프라이닝이 CPU 성능 향상에 실패하는 경우
    - 파이프라인 위험
        - 데이터 위험: 명령어 간의 데이터 의존성에 의해 발생]
        - 제어 위험: 프로그램 카운터의 갑작스러운 변화에 의해 발생
        - 구조적 위험(= 자원 위험): 명령어들을 겹쳐 실행하는 과정에서 서로 다른 명령어가 동시에 ALU, 레지스터 등과 같은 CPU 부품을 사용하려고 할 때 발생