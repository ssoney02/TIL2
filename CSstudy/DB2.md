# 4. 효율적 쿼리

## 서브 쿼리와 조인

- 하나의 SELECT 문으로 여러 테이블 레코드 조회 ⇒ SELECT문의 FROM에 여러 테이블 이름 명시
    
    ```sql
    SELECT 테이블1.필드1, 테이블1.필드2, 테이블2.필드3
    	FROM 테이블1, 테이블2
    	WHERE 테이블1.필드1 = 테이블2.필드2;
    ```
    
- 서브쿼리: 다른 SQL문이 포함된 SQL문
    
    ↔ 외부쿼리
    
- 조인: 여러 테이블을 하나로 합치는 것
    
    ![image.png](attachment:59397c57-1368-40da-9f71-8aec931ca39a:c73e61e8-5631-415f-bfcb-3f24670fbee7.png)
    
    ```sql
    SELECT 필드
    FROM 테이블1
    	___ JOIN 테이블2 ON 조인 조건;
    ```
    
    - INNER 조인: 테이블 A와 B의 레코드 중 조인 조건을 모두 만족하는 레코드를 결과로 반환
    - OUTER 조인
        1. LEFT OUTER 조인: 테이블 A의 모든 레코드를 포함하고, 조인 조건을 만족하는 테이블 B의 레코드를 결과로 반환
            - 조건을 만족하지 않는 B테이블의 필드는 NULL로 채워짐
        2. RIGHT OUTER 조인: 테이블 B의 모든 레코드를 포함하고, 조인 조건을 만족하는 테이블 A의 레코드를 결과로 반환.
            - 조건을 만족하지 않는 A테이블의 필드는 NULL로 채워짐
        3. FULL OUTER 조인: 테이블 A와 B의 모든 레코드를 포함하고, 조인 조건을 만족하지 않는 경우에 상대 테이블의 필드를 NULL로 채워 결과 반환
            - 두 테이블의 모든 레코드를 선택하되, 대응되지 않는 모든 레코드를 NULL로 표기
            - LEFT OUTER 조인과 RIGHT OUTER 조인의 결과를 하나로 합치면 FULL OUTER JOIN 구현 가능
                
                ```sql
                SELECT 필드
                FROM 테이블1
                	LEFT JOIN 테이블2 ON 조인 조건
                	UNION
                SELECT 필드
                FROM 테이블1
                	RIGHT JOIN 테이블2 ON 조인 조건;
                ```
                
        - **UNION**: SQL문 실행 결과의 합집합을 구하는 키워드

## 뷰

SELECT 문의 결과를 토대로 SQL문을 자주 실행해야 할 경우, 매번 서브 쿼리를 작성하기에는 중복되는 쿼리가 많아 번거로움 ⇒ 뷰

: SELECT 문의 결과로 만들어진 가상의 테이블

- 주로 테이블에 대한 SQL문을 단순화하기 위해 사용

```sql
CREATE VIEW 뷰이름 AS SELECT문;
```

- 사용 목적
    1. SQL문 단순화
    2. 특정 사용자에게 테이블의 특정 데이터만을 보여주고자 할 때
        - 테이블 상의 모든 데이터를 모든 데이터베이스 사용자에게 노출하고 싶지 않을 때
            
            → 테이블 상의 노출 가능한 데이터만을 포함하는 뷰를 만들어 특정 사용자에게만 해당 뷰에 대한 접근 권한 부여
            
            - 특정 사용자에게 특정 테이블(뷰)에 대한 권한을 부여하는 명령: GRANT
            
- 유의할 점: 조회(SELECT)에는 제한이 없지만, 삽입,수정,삭제 등은 불가능할 수 o
    - 특히 여러 테이블을 SELECT한 결과로 만들어진 뷰의 경우, 삽입/수정/삭제 연산이 제약 조건을 어기기 쉬움..
    - 뷰 → 조회 목적으로 사용되는 경우가 많음

## 인덱스

: 검색 속도 향상을 목적으로 만드는 하나 이상의 테이블 **필드에 대한** 자료 구조

→ 특정 필드에 대한 인덱스를 생성하면 인덱스를 기준으로 원하는 레코드에 더 빠르게 접근 가능

- MySQL의 인덱스 종류
    1. **클러스터형 인덱스**: 테이블 당 하나씩 만들 수 있는 인덱스 ⇒ “기본 키”
        - 테이블 내에 기본 키로 지정되니 필드 → 기본적으로 클러스터형 인덱스로 간주됨
        - 기본 키로 지정된 필드가 없는 경우 → **NOT NULL 제약 조건 & UNIQUE 제약 조건**이 있는 필드를 클러스터형 인덱스로 간주
    2. **세컨더리 인덱스 (= 논클러스터형 인덱스)**
        
         → 테이블 당 여러 개 존재 가능 (but, 클러스터형 인덱스를 활용한 검색보다 일반적으로 느림)
        
        <세컨더리 인덱스 생성,조회, 삭제>
        
        ```sql
        -- '테이블_이름'의 '필드'에 세컨더리 인덱스인 '인덱스_이름'을 생성
        CREATE INDEX 인덱스_이름 ON 테이블_이름(필드);
        
        -- 인덱스 조회
        SHOW INDEX FROM 테이블_이름;
        
        -- 인덱스 삭제
        DROP INDEX 인덱스_이름 FROM 테이블_이름;
        ```
        
- 인덱스로 사용되는 자료 구조
    1. 해시 테이블
    2. B 트리
        - 각 노드 → 키로써 인덱스 값 표함
            - 인덱스 값 탐색 → 실제 데이터(레코드)가 저장된 위치 알 수 o
        
        ⇒ B트리의 특성 상 다량의 노드에 대한 빠른 검색 가능 → 인덱스를 바탕으로 레코드가 저장된 위치 빠르게 알 수 o
        
        - CREATE INDEX __ ON __();
- 인덱스 생성, 관리의 부작용
    - 인덱스의 저장 공간과 생성 시간 고려해야 됨
    - 조회(SELECT) 성능 향상 가능, but 그 외의 작업(INSERT, UPDATE, DELETE)에 대해서는 오히려 성능 떨어뜨리기도
        - 새로운 데이터를 삽입하거나 기존 데이터 수정/삭제 할 때 **인덱스에 대한 작업**도 동시에 이루어져야 하므로..
- 인덱스 활용 경우
    1. 데이터가 충분히 많지 않은 상황
    2. 조회(SELECT) 연산이 적은 경우 or 삽입(INSERT), 수정(UPDATE), 삭제(DELETE) 연산이 많은 경우
    
    ⇒ 데이터가 충분히 많은 테이블, 조회가 빈번히 이루어지는 테이블 필드에 만들어 활용하는 것이 좋음!
    
    (SELECT문 중에서도 자주 조인되거나 WHERE, ORDER BY에서 자주 언급되는 필드)
    
- 유의사항
    - 일반적으로 테이블 당 3개 이하의 인덱스를 권고
    - 중복되는 데이터가 많은 필드에 대해 인덱스를 생성하는 것은, 그렇지 않은 필드에 대해 인덱스를 생성하는 것보다 인덱스 효능을 떨어뜨림

# 5. 데이터베이스 설계

<효율적으로 테이블을 설계하고 관리하는 방법>

## ER 다이어그램

- 엔티티: 데이터베이스에 저장가능하며 다양한 속성을 가진 객체
- ERD: 엔티티 관계를 표현하는 그림
    - 목적: 데이터베이스에 저장되는 엔티티의 구조 모델링
        - 엔티티구조 모델링: 데이터베이스로 표현할 대상을 시각적으로 설계하는 것
    
    → 추후 데이터베이스를 확장하거나 수정할 때 어떤 부분이 영향을 받는지 쉽게 파악 가능 
    
    → 유지보수 용이, 개발자 간 원활한 소통 가능
    
- 피터 첸 표기법
    
    ![image.png](attachment:3dfde039-c2bd-48db-bc12-82f1fc7d29fe:image.png)
    
- ERD 표기 방식 → IE(Information Engineering notation)표기법 = 새 발 표기법 = 까마귀 발 표기법
    
    ![image.png](attachment:91309980-0aa0-45e9-bc17-cb083ea00528:image.png)
    
- 식별/비식별 관계
    - 실선: 식별 관계
        - 참조되는 엔티티가 존재해야만 → 참조하는 엔티티가 존재할 수 있는 관계
            
            ex. 참조되는 테이블의 기본 키를 / 참조하는 테이블의 외래키이자 기본키로 활용하는 경우  
            
    - 점선: 비식별 관계
        - 참조되는 엔티티가 존재하지 않아도 → 참조하는 엔티티가 존재할 수 있는 관계
            
            ex. 참조되는 테이블의 기본 키를 / 참조하는 테이블의 기본 키가 아닌! 일반적인 외래 키로 이용하는 경우
            

## 정규화

: 하나의 테이블을 어떤 필드로 구성해야 할 지 결정하는 작업

### 제 1 정규형

- 필요충분조건: 모든 속성이 **원자 값**을 가짐
    
    → 필드 데이터가 더 이상 쪼개질 수 없는 값을 가져야 함
    

### 제 2 정규형

: **제 1정규형을 만족**함과 동시에, **기본 키가 아닌 모든 필드들이 모든 기본 키에 완전히 종속**될 것이라는 필요충분조건을 만족하는 상태

- 즉, 테이블의 모든 필드가 기본 키에 완전히 종속되어야 하고,
    - (기본 키가 여러 필드로 구성될 경우) 일부 기본 키에만 종속되어서도 안됨
- 특정 필드(속성) X의 값을 통해 → 특정필드(속성) Y의 유일한 값이 결정될 경우
    - “Y가 X에 종속적”
    - X: 결정자, Y: 종속자
- **부분 함수 종속성**: 기본 키가 아닌 필드가 기본 키의 일부에 종속되어 있는 경우
- **완전 함수 종속성**: 기본 키 전체에 완전하게 종속되어 있는 경우

⇒ 부분 함수 종속성이 없는 상태, (후보 키에 속하지 않는 모든 필드가) 기본 키에 완전 함수 종속인 상태

### 제 3 정규형

: 제 2 정규형을 만족하면서, 기본 키가 아닌 모든 필드가 기본 키에 이행적 종속성이 없는 상태

- 이행적 종속관계
    
    ex. A,B,C라는 필드가 있을 때,
    
    A → B를 결정하고 , B→C를 결정한다면 
    
    ⇒ A → C를 결정하게 되어 A→C 종속 관계 형성됨
    

⇒ 기본 키가 아닌 나머지 모든 필드들이 간접적으로라도 종속되어서는 안됨

기본 키가 아닌 나머지 모든 필드는 서로를 유추하거나 결정할 수 없어야

### 보이스/코드 정규형(BCNF)

: 제 3 정규형을 만족하는 동시에 **모든 결정자가 후보키** 여야 함

- 결정자: 특정 필드를 식별할 수 있는 필드
- 키가 아닌데 다른 필드의 결정자 역할  → 보이스/코드 정규형 만족x
    
    ![image.png](attachment:7cd9ea6a-5ec9-4ebd-880f-d992cd5df5fb:316e420c-91f8-4f08-9036-7c1d0b217096.png)
    
- **역정규화**
    
    : 검색의 속도를 높이기 위해 **분할되어 있는 테이블을 하나로 합치는** 작업
    
    - 정규화 많이 할 수록 → 데이터 깔끔 / 데이터베이스 작업 시 이상 현상 줄어듦 but 성능 저하 발생 가능

- **도큐먼트 데이터베이스(=문서지향 데이터베이스)**
    
    → 레코드를 **도큐먼트**라는 단위로 저장, 관리
    
    - 도큐먼트: 정형화되어 있지 않은 NoSQL 레코드의 단위를 통칭 하기 위해 사용하는 용어
    - MongoDB → 하나의 레코드를 **JSON 형태**로 만들어 관리
        - 키 → 필드 / JSON데이터 하나 하나 →RDBMS의 행
        - MongoDB → RDBMS와 달리 고정된 스키마가 없어 각 도큐먼트가 유연한 스키마 가질 수 o
        - 도큐먼트가 모여 → ‘**컬렉션**’ → 데이터베이스
            
            cf. RDBMS: 레코드 → 테이블 → 데이터베이스
            
- **그래프 데이터베이스**
    
    : 데이터를 그래프의 **노드 형태**로 저장
    
    - 노드 간 **연결관계**와 **방향** 표현 가능
        
        ex. sns의 친구관계, 교통망 등 데이터 간의 관계성이 중요한 레코드 저장
        
- **칼럼 패밀리 데이터베이스**
    
    → RDBMS와 같이 행/열 개념 가짐
    
    - **로우 키 (row key)**를 통해 특정 행 식별
    - but, RDBMS와 달리 정규화나 조인 사용x, 스키마가 고정되어 있지 않아 자유롭게 열 추가 가능
    - 관련 있는 **열**들이 모여 → **칼럼 패밀리(column family)** → **키스페이스(keyspace)**
        - **키스페이스** : 칼럼 패밀리 데이터베이스의 최상위 단위
            - 일반적으로 애플리케이션마다 키스페이스 하나 사용
            
            ![image.png](attachment:ea57234f-c160-4476-ab3d-bf1e9ce9dc6c:image.png)
            
- NoSQL
    
    → 높은 부하를 감당하거나 / 대용량 데이터를 다루는 분산 환경에서 good
    
    - NoSQL 데이터베이스가 지향하는 주된 목적 중 하나: **용이한 스케일 아웃**
    - **확장성, 가용성, 유연성** 높음
    - RDBMS에 비해 데이터 무결성, 일관성 다소 저하 가능
        - ACID에 대한 엄격한 준수, 데이터 무결성, 일관성 유지가 중요한 환경 ⇒ RDBMS가 더 적합
    
- MongoDB
    - 특정 컬렉션의 도큐먼트 확인 명령 : ‘db.컬렉션_이름.find()’
    - 여러 레코드 삽입 : ‘db.컬렉션_이름.insertMany()’
        - 소괄호 안에 삽입할 여러 도큐먼트를 리스트 형태로 명시
    - 단일 도큐먼트 갱신: ‘db.컬렉션_이름.updateOne()’
        - 첫 번째 인자: 갱신할 도큐먼트 식별하는 필터
        - 두 번째 인자: 갱신할 내용
            
            $set: { 변경할_필드: 변경할_내용, …}
            
    - 여러 도큐먼트 갱신: ‘db.컬렉션_이름.updateMany()’
    - 단일 도큐먼트 삭제: db.컬렉션_이름.deleteOne()
    - 여러 도큐먼트 삭제: db.컬렉션_이름.deleteMany()
- Redis
    - 레코드 → 키-값 대응 쌍으로 관리
        - 값으로 활용될 수 있는 자료 구조 → 문자열, 리스트, 해시 테이블, 집합 등
    - 문자열
        - SET: 문자열 값 저장
        - SETNX: 키가 존재하지 않는 경우에만 문자열 값 저장(set if not exists)
        - GET: 문자열 값 조회(키를 통해 대응되는 값 조회)
        - MGET: 여러 문자열 값 조회
        - DEL: 키 삭제
    - 리스트
        - LPUSH: 리스트의 왼쪽(앞)에 새로운 요소 추가
        - RPUSH: 리스트의 오른쪽(뒤)에 새로운 요소 추가
        - LPOP: 리스트의 왼쪽(앞)에서 요소를 제거 후 반환
        - RPOP: 리스트의 오른쪽(뒤)에서 요소를 제거 후 반환
        - LRANGE: 지정된 범위의 요소들을 반환
        - LLEN: 리스트 길이 반환
    
- 데이터베이스 분할과 샤딩
    - 데이터 베이스 분할(데이터베이스 파티셔닝): 안정적이고 확장성 높은 데이터베이스 레코드 관리를 위해 테이블을 물리적으로 분할하여 레코드를 저장하는 기술
    - 파티션: 분할되어 저장되는 단위
    - 수평적 분할: 테이블을 행을 기준으로 테이블을 나누어 저장하는 방식
        
        → 테이블의 레코드를 참조할 때마다 모든 레코드를 한 번에 불러들일 필요가 없는 경우 → 수평적으로 분할
        
        1. **범위 분할**: 레코드 데이터가 가질 수 있는 범위를 정의하고, 해당 범위를 기준으로 테이블 나눔
        2. **목록 분할**: 레코드 데이터가 특정 목록(리스트)에 포함된 값을 가질 경우 
            
            해당 레코드를 별도의 테이블로 분할
            
        3. **해시 분할**: 특정 열 데이터에 대한 해시 값을 기준으로 별도의 테이블로 분할
            - 파티션별 레코드가 해시 값을 기준으로 균등하게 분배
        4. **키 분할**: 파티션별 레코드가 키를 기준으로 균등하게 분배
        - 분할된 테이블을 조회할 때, 특정 레코드가 속한 파티션의 식별 ⇒ **파티셔닝 키**를 통해 이루어짐
        - 분할된 테이블이 모두 같은 데이터베이스 서버에 위치할 경우, 해당 서버에 요청이 몰리는 상황에서 부하 분산을 기대하기 어려움
            
            ⇒ sol) **샤딩** → 수평적 분할 기술
            
            : **분할된 테이블**을 별개의 **데이터베이스 서버**에 분산하여 저장하는 기술
            
            → 샤드를 여러 서버에 분산하여 저장하는 수평적 분할 기법
            
            ⇒ 분할된 샤드들이 여러 서버에 분산되어 저장되므로 부하 분산 효과 얻을 수 o
            
            - **샤드**: 분할되어 저장된 단위
            
    - 수직적 분할: 테이블의 **열을 기준**으로 테이블을 나누어 저장하는 방식